---
title: "3.3 Launch Files & Parameters"
sidebar_label: "3.3 Launch Files & Parameters"
---

import Mermaid from '@theme/Mermaid';

## Learning Outcomes

After completing this section, you will be able to:
- Understand the purpose and structure of ROS 2 launch files.
- Create and run complex robotic systems with multiple nodes using launch files.
- Use parameters to make your ROS 2 nodes more flexible and configurable.
- Define and manage parameters in launch files for easy modification.

## 1. Introduction to ROS 2 Launch Files

In complex robotic systems, you often need to run multiple nodes simultaneously. Managing them manually through separate terminal windows can be cumbersome and error-prone. ROS 2 launch files provide a powerful and convenient way to start and configure multiple nodes and their parameters with a single command.

A launch file is a script that automates the process of running ROS 2 executables. It allows you to:
- Launch multiple nodes at once.
- Configure node parameters.
- Set up node namespaces and remappings.
- Conditionally launch nodes based on arguments.

This section will guide you through the fundamentals of creating and using launch files to manage your robotic applications efficiently.

## 2. Creating a Basic Launch File

Let's start by creating a simple launch file to run a single ROS 2 node.

### 2.1. Structure of a Launch File
ROS 2 launch files are typically written in Python and use a declarative syntax to define how nodes and other components should be started. A basic launch file includes the necessary imports and a `generate_launch_description` function that returns a `LaunchDescription` object.

Here's an example of a simple `my_first_launch.py` file:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='demo_nodes_py',
            executable='talker',
            name='my_talker',
            output='screen',
            emulate_tty=True
        )
    ])
```

**Explanation:**
*   **`LaunchDescription`**: The root element of a launch file, containing all the actions to be executed.
*   **`Node`**: Represents a single ROS 2 node to be launched.
    *   **`package`**: The name of the ROS 2 package where the executable is located.
    *   **`executable`**: The name of the executable to run (e.g., `talker` or `listener`).
    *   **`name`**: An optional, unique name for this instance of the node. If not provided, a default name will be used.
    *   **`output='screen'`**: Redirects the node's console output to the screen, which is useful for debugging.
    *   **`emulate_tty=True`**: Ensures that output is buffered line-by-line, providing a more readable output.

### 2.2. Running a Launch File

To run a launch file, navigate to your workspace and use the `ros2 launch` command:

```bash
ros2 launch your_package_name my_first_launch.py
```

Replace `your_package_name` with the actual name of your ROS 2 package (where the launch file is located) and `my_first_launch.py` with the name of your launch file.

When you run this, you should see the `my_talker` node starting and publishing messages to the `chatter` topic.

## 3. Managing Parameters in Launch Files

Parameters are values that nodes can load at startup and change at runtime, allowing for flexible configuration without recompiling code. Launch files are an ideal place to define and manage these parameters.

### 3.1. Declaring and Setting Parameters

Parameters can be declared directly within the `Node` action in a launch file:

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        Node(
            package='my_package',
            executable='my_node',
            name='my_configurable_node',
            output='screen',
            emulate_tty=True,
            parameters=[
                {'param_name_1': 'value1'},
                {'param_name_2': 123},
                {'param_name_3': True}
            ]
        )
    ])
```

**Explanation:**
*   The `parameters` argument takes a list of dictionaries, where each dictionary represents a parameter with its name and value.
*   Parameters can be of various types: strings, integers, booleans, floats, etc.

### 3.2. Loading Parameters from YAML Files

For more complex configurations or a large number of parameters, it's often better to load them from a YAML file. This keeps your launch files cleaner and allows for easier parameter management.

First, create a YAML file (e.g., `config/my_params.yaml`):

```yaml
my_configurable_node:
  ros__parameters:
    param_name_1: "value_from_yaml"
    param_name_2: 456
    param_name_3: false
```

Then, modify your launch file to load these parameters:

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    config_dir = os.path.join(
        get_package_share_directory('my_package'),
        'config'
    )
    params_file = os.path.join(config_dir, 'my_params.yaml')

    return LaunchDescription([
        Node(
            package='my_package',
            executable='my_node',
            name='my_configurable_node',
            output='screen',
            emulate_tty=True,
            parameters=[
                params_file
            ]
        )
    ])
```

**Explanation:**
*   `get_package_share_directory('my_package')` helps locate the install directory of your package.
*   `os.path.join` is used to construct the full path to your `my_params.yaml` file.
*   The `parameters` argument can directly take the path to a YAML file, loading all parameters defined within it.

### 3.3. Accessing Parameters in Nodes

In a ROS 2 C++ or Python node, you can access these parameters using the client library API:

**Python Example (`my_node.py`):**

```python
import rclpy
from rclpy.node import Node

class MyConfigurableNode(Node):
    def __init__(self):
        super().__init__('my_configurable_node')
        self.declare_parameter('param_name_1', 'default_value_1')
        self.declare_parameter('param_name_2', 0)
        self.declare_parameter('param_name_3', False)

        param_1 = self.get_parameter('param_name_1').get_parameter_value().string_value
        param_2 = self.get_parameter('param_name_2').get_parameter_value().integer_value
        param_3 = self.get_parameter('param_name_3').get_parameter_value().bool_value

        self.get_logger().info(f'Param 1: {param_1}')
        self.get_logger().info(f'Param 2: {param_2}')
        self.get_logger().info(f'Param 3: {param_3}')

def main(args=None):
    rclpy.init(args=args)
    node = MyConfigurableNode()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

**Explanation:**
*   **`self.declare_parameter('param_name', default_value)`**: Declares a parameter with a default value. This is good practice even if the parameter is set via a launch file, as it provides a fallback and documents the expected parameters.
*   **`self.get_parameter('param_name')`**: Retrieves the `Parameter` object.
*   **`.get_parameter_value().string_value` (or `integer_value`, `bool_value`, etc.)**: Extracts the actual value from the `Parameter` object, cast to the correct type.

Parameters provide immense flexibility, allowing you to reuse nodes in different contexts without modifying their source code, which is essential for building scalable and adaptable robotic systems.

## 4. Advanced Launch File Concepts

Advanced launch files provide powerful features to handle complex robotic systems, including conditional execution, event handling, and the ability to include other launch files.

### 4.1. Including Other Launch Files

One of the most useful features of ROS 2 launch files is the ability to include other launch files. This promotes modularity and reusability, allowing you to build complex system launches from smaller, more manageable components.

```python
from launch import LaunchDescription
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # Get the path to the other_package launch directory
    other_launch_file_dir = os.path.join(
        get_package_share_directory('other_package_name'),
        'launch'
    )

    return LaunchDescription([
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource([
                other_launch_file_dir,
                '/another_launch_file.py'
            ])
        ),
        # You can add more nodes or actions here for this launch file
        Node(
            package='my_package',
            executable='my_additional_node',
            name='my_additional_node_name',
            output='screen'
        )
    ])
```

**Explanation:**
*   **`IncludeLaunchDescription`**: This action allows you to embed the content of another launch file into the current one.
*   **`PythonLaunchDescriptionSource`**: Specifies that the included launch file is a Python-based launch file.
*   `get_package_share_directory` is used to find the path to the package containing the launch file to be included, making the launch file portable.

### 4.2. Launch Arguments

Launch arguments provide a way to pass values into your launch files at runtime, making them more flexible. These are similar to command-line arguments but are handled within the ROS 2 launch system.

**Defining Launch Arguments:**

```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node

def generate_launch_description():
    # Declare a launch argument named 'robot_name' with a default value
    robot_name_arg = DeclareLaunchArgument(
        'robot_name',
        default_value='my_robot',
        description='Name of the robot'
    )

    return LaunchDescription([
        robot_name_arg,
        Node(
            package='my_package',
            executable='robot_controller',
            name=LaunchConfiguration('robot_name'),
            output='screen',
            emulate_tty=True
        )
    ])
```

**Explanation:**
*   **`DeclareLaunchArgument`**: Defines a new argument that can be passed to the launch file. You can specify a `default_value` and a `description`.
*   **`LaunchConfiguration('argument_name')`**: Used to access the value of a declared launch argument within the launch file.

**Passing Launch Arguments:**

You can pass launch arguments from the command line:

```bash
ros2 launch my_package my_launch_file.py robot_name:=my_new_robot
```

### 4.3. Conditional Launching

Launch files allow you to conditionally launch nodes or other actions based on conditions, often using launch arguments.

```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, GroupAction
from launch.substitutions import LaunchConfiguration
from launch.conditions import IfCondition, UnlessCondition
from launch_ros.actions import Node

def generate_launch_description():
    use_debug_node_arg = DeclareLaunchArgument(
        'use_debug_node',
        default_value='false',
        description='Set to true to launch the debug node'
    )

    # Define a group of actions that are launched only if use_debug_node is true
    debug_node_group = GroupAction(condition=IfCondition(LaunchConfiguration('use_debug_node')),
        actions=[
            Node(
                package='my_package',
                executable='debug_node',
                name='my_debug_node',
                output='screen'
            )
        ]
    )

    return LaunchDescription([
        use_debug_node_arg,
        debug_node_group,
        Node(
            package='my_package',
            executable='main_node',
            name='my_main_node',
            output='screen'
        )
    ])
```

**Explanation:**
*   **`IfCondition` / `UnlessCondition`**: These conditions take a `LaunchConfiguration` (which evaluates a launch argument) and control whether the associated actions are executed.
*   **`GroupAction`**: Useful for applying a condition to multiple actions simultaneously.

This allows for highly flexible launch configurations, where you can easily enable or disable features, swap components, or change parameters based on the deployment environment or debugging needs.

## 5. Exercises

... exercises to be added here ...

## 6. Review Questions

... review questions to be added here ...
